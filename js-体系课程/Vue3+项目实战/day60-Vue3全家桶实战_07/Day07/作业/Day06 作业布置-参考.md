# Day06 作业布置

## 一. 完成上课所有的代码练习







## 二. ref和reactive有什么区别？开发中如何选择？

- ref可以包裹任意数据类型
- reactive只能包裹复杂数据类型，比如对象、数组



- ref返回一个ref对象，在script中取值需要通过value属性，但是在模板中使用会进行解包不需要调用value
- reactive包裹的是复杂数据类型，直接取里面的属性即可



- ref几乎可以应用在任何场景，而且包含reactive适合的场景
- reactive的应用场景比较受限，第一：值比较固定，第二：值与值之间是有联系的



- 开发中尽量选择ref





## 三. 整理Composition API常见的几个函数用法

* ref
  * 包裹任意类型的值，将包裹的值加入响应式
* reactive
  * 包裹复杂类型的值，将包裹的值加入响应式
* readonly
  * 我们通过父组件向子组件传递数据后，子组件拿到数据，在组件中是不能修改这个拿到的数据
  * 因为这不符合单项数据流的原则
  * 如果你想这样做，需要在子组件发射事件并携带参数，父组件进行事件监听，然后再修改传递的值
  * 但是为了避免子组件误操作，我们需要为其包裹一个readonly
  * 这样传递过去的值，被更改时，会报警告，且执行失败
* computed
  * 把一些复杂逻辑用computed进行包裹，如同Options API中的计算属性一样
  * computed会自动收集相关依赖，当依赖发生变化时，会自动进行更新
* 生命周期
  * 想要在beforeCreate和created中做的事，直接在setup中做即可
  * 其他的生命周期函数都要在前面加一个on，然后需要在vue中主动引入
* watch
  * watch可以监听单个数据源，也可以监听多个数据源
  * watch是懒执行，第一次是不会执行的，除非你为其提供第三个参数中的immediate属性为true
  * watch只有等到监听的数据源发生了变化后，才会执行第二个参数（回调）
  * watch可以获取监听数据源的前后变化的值
  * 侦听多个数据源的时候，第一个参数是数组类型
* watchEffect
  * watchEffect会自动收集依赖，收集的依赖是第一个参数，也就是回调函数中有哪些东西是加入响应式的
  * 如果这个值加入了响应式就会被收集起来，当被收集的值发生了变化，就会重新执行这个回调函数
  * watchEffect第一次执行是在DOM挂载前执行的，所以如果你想在第一次执行时拿到DOM元素
  * 需要传入第二个参数，第二个参数是一个对象，让其flush属性的值为post即可
* toRefs
  * 对reactive进行解构后就失去了响应式的效果，因为reactive返回的是一个Proxy对象
  * 对Proxy对象进行解构，拿到的是纯净的值，所以没有了响应式的效果
  * 如果想要对reactive进行解构，需要对其包裹一个toRefs
  * 这么做相当于为reactive中的每一个值包裹了一个ref





## 四. watch和watchEffect有什么区别？

* 懒执行副作用（第一次不会直接执行）；

* 更具体的说明当哪些状态发生变化时，触发侦听器的执行；

* 访问侦听状态变化前后的值；

* watch
  * watch可以监听单个数据源，也可以监听多个数据源
  * watch是懒执行，第一次是不会执行的，除非你为其提供第三个参数中的immediate属性为true
  * watch只有等到监听的数据源发生了变化后，才会执行第二个参数（回调）
  * watch可以获取监听数据源的前后变化的值
  * 侦听多个数据源的时候，第一个参数是数组类型
* watchEffect
  * watchEffect会自动收集依赖，收集的依赖是第一个参数，也就是回调函数中有哪些东西是加入响应式的
  * 如果这个值加入了响应式就会被收集起来，当被收集的值发生了变化，就会重新执行这个回调函数
  * watchEffect第一次执行是在DOM挂载前执行的，所以如果你想在第一次执行时拿到DOM元素
  * 需要传入第二个参数，第二个参数是一个对象，让其flush属性的值为post即可



## 五. 说说script setup语法糖的常见用法

1.script setup

- 当使用  script setup  的时候，任何在  script setup  声明的顶层绑定都能在模板中直接使用
  - 声明的顶层绑定：包括变量，函数声明，以及 import 引入的内容
- 响应式数据需要通过ref、reactive来创建
- 在script setup中导入的组件可以直接使用

2.defineProps和defineEmits

- 使用的时候不是props.name，这个props另有它用，这里直接使用即可

3.defineExpose

- 我们通过ref获取到组件这个组件是一个ref的对象，还要通过value拿到组件实例

- 拿到组件实例后我们可以访问这个组件中的方法

- 之所以可以访问这个组件中的方法，是因为我们给他返回了

- 但是在script setup中我们不没有进行返回，所以访问不到

- 这个时候就需要将我们想要访问的方法或者变量使用defineExpose进行暴露即可

- defineProps、defineEmits、defineExpose不需要导入，直接使用即可





## 六. 完成阶段案例实战练习













































